var PathTemplate = exports;

MissingVariableError = function (message) {
	this.name = "MissingVariableError";
	this.message = message || "variable not defined";
};
MissingVariableError.prototype = new Error();
MissingVariableError.prototype.constructor = MissingVariableError;
PathTemplate.MissingVariableError = MissingVariableError;

var SLASH = ["string", "/"];
var DOT = ["string", "."];

var tokenize = function (string) {
	return string.split(/([\/:*.)(])/).filter(function (x) {
		return x;
	});
};

var lex = function (tokens) {
	var parts = [],
		tokensLength = tokens.length,
		i,
		token,
		optionalPartsConsumed,
		optionalParts;
	for (i = 0; i < tokensLength; i += 1) {
		token = tokens[i];
		if (token === "/") {
			parts.push(["string", token]);
		} else if (token === ":") {
			parts.push(["variable", tokens[i += 1]]);
		} else if (token === "*") {
			token = tokens[i += 1];
			if (token === "/" || token === ".") {
				i -= 1;
				token = null;
			}
			parts.push(["splat", token]);
		} else if (token === "(") {
			optionalPartsConsumed = lex(tokens.slice(i + 1));
			optionalParts = optionalPartsConsumed[0];
			parts.push(["option", optionalParts.length]);
			parts = parts.concat(optionalParts);
			i += optionalPartsConsumed[1] + 1;
		} else if (token === ")") {
			break;
		} else {
			parts.push(["string", token]);
		}
	}
	return [parts, i];
};

/**
 * Returns a compiled path template, generated from the given string.
 * 
 * @example
 * var template = PathTemplate.parse("/users/:userID");
 * 
 * @param {string} string A URL path template
 * @returns {PathTemplate} A compiled path template
 */
PathTemplate.parse = function (string) {
	var partsConsumed = lex(tokenize(string));
	return partsConsumed[0];
};

/**
 * Returns the string representation of a compiled path template.
 * 
 * @example
 * console.log(PathTemplate.inspect(template));
 * 
 * @param {PathTemplate} template A compiled path template
 * @returns {string} the string representation of template
 */
PathTemplate.inspect = function recursiveInspect(template) {
	if (template.length === 0) {
		return "";
	}
	
	var head = template.slice(0, 1)[0],
		value = head[1],
		tail = template.slice(1),
		out;
	
	switch (head[0]) {
	case "variable":
		out = ":" + value;
		break;
	case "splat":
		out = value ? "*" + value : "*";
		break;
	case "option":
		out = "(" + recursiveInspect(tail.slice(0, value)) + ")";
		tail = tail.slice(value);
		break;
	default:
		out = value;
	}
	
	return out + recursiveInspect(tail);
};

/**
 * Returns the variable names (including splats/globs) used in a path template.
 * 
 * @example
 * var keys = PathTemplate.variables(template);
 * 
 * @param {PathTemplate} template A compiled path template
 * @returns {Array} the variable names used in template
 */
PathTemplate.variables = function (template) {
	var acc = [],
		templateLength = template.length,
		i,
		part,
		type,
		val;
	for (i = 0; i < templateLength; i += 1) {
		part = template[i];
		type = part[0];
		val = part[1];
		if (type === "variable") {
			acc.push(val);
		} else if (type === "splat" && val) {
			acc.push(val);
		}
	}
	return acc;
};

/**
 * Returns a URL path generated by substituting the variables in template with
 * the values of the correspondingly named properties in an object.
 * 
 * @example
 * var url = PathTemplate.format(template, {userID: 1});
 * 
 * @param {PathTemplate} template A compiled path template
 * @param {Object} obj An object with properties corresponding with the
 *                     variables in template
 * @returns {string} the URL path generated from combining template and obj.
 */
PathTemplate.format = function recursiveFormat(template, obj, throwOnMissing) {
	if (template.length === 0) {
		return "";
	}
	
	var head = template.slice(0, 1)[0],
		value = head[1],
		tail = template.slice(1),
		out = "",
		referencedValue,
		rest;
	
	switch (head[0]) {
	case "string":
		out = value;
		break;
	case "variable":
		referencedValue = obj[value];
		if (typeof referencedValue !== "undefined") {
			out = referencedValue;
		} else if (throwOnMissing) {
			throw new MissingVariableError(value + " is not defined");
		}
		break;
	case "splat":
		referencedValue = obj[value];
		if (Array.isArray(referencedValue)) {
			out = referencedValue.join("/");
		} else if (typeof referencedValue !== "undefined") {
			out = referencedValue;
		}
		break;
	case "option":
		try {
			out = recursiveFormat(tail.slice(0, value), obj, true);
		} catch (e) {
			if (!(e instanceof MissingVariableError)) {
				throw e;
			}
		}
		tail = tail.slice(value);
		break;
	}
	
	rest = recursiveFormat(tail, obj, throwOnMissing);
	if (out === "/" && rest[0] === "/") {
		return rest;
	}
	return out + rest;
};

var matcherFinished = function(matcher) {
	var i = matcher.index,
		max = matcher.template.length,
		current;
	if (i < max) {
		while (i < max) {
			current = matcher.template[i];
			if (current[0] === "splat") {
				i += 1;
			} else if (current[0] === "option") {
				i += (1 + current[1]);
			} else {
				return false;
			}
		}
	}
	return true;
};

var copyCaptures = function(captures, prototype) {
	var copy = Object.create(prototype || {}),
		prop;
	for (prop in captures) {
		if (captures.hasOwnProperty(prop)) {
			copy[prop] = captures[prop];
		}
	}
	return copy;
};

var matcherAdvancers = {
	string: function (matcher, string, value) {
		if (string === value) {
			return [{template: matcher.template, index: matcher.index + 1,
				captures: matcher.captures}];
		}
	},
	
	variable: function (matcher, string, value) {
		var captures = copyCaptures(matcher.captures);
		captures[value] = string;
		return [{template: matcher.template, index: matcher.index + 1,
			captures: captures}];
	},
	
	splat: function (matcher, string, value) {
		var captures = copyCaptures(matcher.captures),
			matchNext,
			newMatcher;
			
		if (value && !captures[value]) {
			captures[value] = [];
		}
		
		// try the next part of the template to see if the splat has ended
		matchNext = advanceMatcher({template: matcher.template,
			index: matcher.index + 1, captures: captures}, string);
		
		// if the next didn't match and it's a slash, try skipping it
		// this is meant for zero width splats, e.g. /foo/*/bar match /foo/bar
		if (!matchNext && arrayEql(matcher.template[matcher.index + 1], SLASH)){
			matchNext = advanceMatcher({template: matcher.template,
				index: matcher.index + 2, captures: captures}, string);
		}
		
		if (matchNext) {
			captures = copyCaptures(captures);
		}
		
		if (string !== "/" && value) {
			captures[value] = captures[value].concat(string);
		}
		
		newMatcher = {template: matcher.template, index: matcher.index,
			captures: captures};
		if (matchNext) {
			return matchNext.concat(newMatcher);
		}
		return [newMatcher];
	},
	
	option: function (matcher, string, value) {
		var captures = copyCaptures(matcher.captures),
			matchers = [],
			matchNext,
			matchAhead;
		
		matchNext = advanceMatcher({template: matcher.template,
			index: matcher.index + 1, captures: captures}, string);
		
		if (matchNext) {
			captures = copyCaptures(captures);
			matchers = matchers.concat(matchNext);
		}
		
		matchAhead = advanceMatcher({template: matcher.template,
			index: matcher.index + 1 + value, captures: captures}, string);
		
		if (matchAhead) {
			matchers = matchers.concat(matchAhead);
		}
		
		return matchers;
	}
};

var advanceMatcher = function(matcher, string) {
	var part = matcher.template[matcher.index];
	if (part && part[0]) {
		return matcherAdvancers[part[0]](matcher, string, part[1]);
	}
};

var flattenCompact = function (array) {
	return array.reduce(function (acc, ary) {
		if (ary) {
			acc = acc.concat(ary);
		}
		return acc;
	}, []);
};

var outputCaptures = function (captures, template) {
	var last = template.slice(-1)[0],
		val = last[1];
	captures = copyCaptures(captures, {template: template});
	if (last[0] === "splat" && val && typeof captures[val] === "undefined") {
		captures[val] = [];
	}
	return captures;
};

/**
 * If string is a path matching the format of template, returns a match object
 * containing the parameters found in the path, otherwise returns undefined.
 * 
 * An array of templates can be given as the first argument, in which case a
 * match object will be returned if any of the templates match. The match object
 * will have a "template" property referencing the template with which the path
 * matched.
 * 
 * @example
 * var match = PathTemplate.match(templates, url.pathname);
 * 
 * @param {Array|PathTemplate} templates An array of, or single, compiled path
 *                                       templates
 * @param {string} template A URL path to match against
 * @returns {Object|undefined} the values of the variables used in the matched
 *                             template, or undefined if none match
 */
PathTemplate.match = function (templates, string) {
	if (typeof templates[0][0] === "string") {
		templates = [templates];
	}
	var matchers = templates.map(function (template) {
			return {template: template, index: 0, captures: {}};
		}),
		parts = tokenize(string),
		part,
		matcher,
		advancer = function (m) {
			return advanceMatcher(m, part);
		};
	
	for (i = 0; i < parts.length; i += 1) {
		part = parts[i];
		matchers = flattenCompact(matchers.map(advancer));
		if (matchers.length === 0) {
			return;
		}
	}
	for (i = 0; i < matchers.length; i += 1) {
		matcher = matchers[i];
		if (matcherFinished(matcher)) {
			return outputCaptures(matcher.captures, matcher.template);
		}
	}
};

var arrayEql = function (a, b) {
	return a && b && !(a < b || a > b);
};

var addTemplate = function (template, other) {
	if (other.length === 0) {
		return template.slice();
	}
	var tLast = template[template.length - 1],
		oFirst = other[0];
	if (arrayEql(tLast, oFirst) && arrayEql(tLast, SLASH)) {
		other = other.slice(1);
	} else if (!(arrayEql(tLast, SLASH) || arrayEql(oFirst, SLASH) ||
		arrayEql(tLast, DOT) || arrayEql(oFirst, DOT))) {
		other = [SLASH].concat(other);
	}
	return template.concat(other);
};

/**
 * Returns a new path template by appending the path described by string.
 * 
 * @example
 * var photoTemplate = PathTemplate.add(template, "/photos/:photoID");
 * 
 * @param {PathTemplate} template A compiled path template
 * @param {string} string A URL path template
 * @returns {PathTemplate} A compiled path template
 */
PathTemplate.add = function (template, string) {
	return addTemplate(template, PathTemplate.parse(string));
};

var range = function (start, end, exclusive) {
	var acc = [],
		i;
	for (i = start; exclusive ? i < end : i <= end; i += 1) {
		acc.push(i);
	}
	return acc;
};

var zip = function (array, other) {
	var acc = [],
		i;
	for (i = 0; i < array.length; i += 1) {
		acc.push([array[i], other[i]]);
	}
	return acc;
};

var subsectionIndexOf = function (array, other) {
	var aLength = array.length,
		oLength = other.length,
		diffrence = aLength - oLength,
		sections = zip(range(0, diffrence), range(oLength - 1, aLength, true)),
		i,
		start,
		end;
	for (i = 0; i < sections.length; i += 1) {
		start = sections[i][0];
		end = sections[i][1];
		if (arrayEql(array.slice(start, end + 1), other)) {
			return sections[i];
		}
	}
};

var withoutTemplate = function (template, other) {
	var toRemove = subsectionIndexOf(template, other),
		start,
		end,
		result = template;
	if (toRemove) {
		start = template.slice(0, toRemove[0]);
		end = template.slice(toRemove[1] + 1);
		result = addTemplate(start, end);
	}
	return result;
};

/**
 * Returns a new path without the path segments described by string.
 * 
 * @example
 * var photosTemplate = PathTemplate.without(photoTemplate, "/:photoID");
 * 
 * @param {PathTemplate} template A compiled path template
 * @param {string} string A URL path template
 * @returns {PathTemplate} A compiled path template
 */
PathTemplate.without = function (template, string) {
	return withoutTemplate(template, PathTemplate.parse(string));
};
